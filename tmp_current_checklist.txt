# MVP Checklist — "Imagine"-style Agentic UI Builder

Purpose: deliver a local-first web app where a UI conductor agent (Gui, pronounced "guy") builds interactive windows via commands, with a saved desktop per user. Start with SQLite/Next.js; use Qwen 3 for Gui and Kimi K2 for code generation.

## 0) Ground Rules
- [ ] Model must not emit JavaScript. All UI changes via tools/commands only.
- [ ] Sanitize any HTML before rendering (block script/style/on* handlers; allowlist tags/attrs).
- [ ] Stream outputs; execute tool calls when present; display only user-facing assistant text. Do not reveal hidden reasoning.
- [ ] Persist desktop state; restore on login.

## 1) Frontend Shell (Desktop + Windows)
- [ ] Next.js + React + Tailwind app scaffold.
- [ ] Draggable/resizable windows (sizes: `xs=320`, `sm=480`, `md=640`, `lg=896`, `xl=1152`).
- [ ] Window chrome: titlebar, close/focus, z‑stack management.
- [ ] Content pane renders sanitized HTML (DOMPurify or equivalent). No inline styles unless whitelisted.
- [ ] Event delegation at window root: capture `click|input|submit|change` with `id`/`data-*` and send as `ui_event`.
- [ ] Desktop layout persistence (positions, z-index, sizes) per user/workspace.

## 2) Realtime Transport
- [ ] WebSocket (or SSE) client connection per session.
- [ ] Channel topics: `commands` (model→client), `events` (client→model), `status` (logs/errors), `plan` (optional UI plan updates).
- [ ] Reconnect/resume logic; drop stale commands by idempotency keys.

## 3) Command/Tool Schema (Model → Frontend)
- [ ] Implement tools as server endpoints that forward to the client executor:
  - [ ] `window_new`: `{ id, title, size: "xs|sm|md|lg|xl", x?:number, y?:number }`
  - [ ] `dom_replace_html`: `{ selector, html, sanitize?: boolean }`
  - [ ] `init_tool`: `{ tool: "chart_js|mermaid|leaflet", options?:{} }`
  - [ ] `chart_render`: `{ target, library:"chart_js", spec:object }`
  - [ ] `mermaid_render`: `{ target, definition:string }`
  - [ ] `map_show`: `{ target, center:[lat,lng], zoom?:number, markers?:[] }`
  - [ ] `notify`: `{ level:"info|warn|error", message:string }` (optional)
  - [ ] `focus_window`: `{ id }` / `close_window`: `{ id }` (optional)
  - [ ] `web_search`: `{ query:string, k?:number }` (backend-only; returns results to model)
- [ ] JSON Schema validation + error surface back to model.
- [ ] DSL fallback (strict line-based) for non-tool models (post‑MVP if needed).

## 4) Model Providers & Adapter
- [ ] Gui (UI conductor): Qwen 3 with tool-calling (ChatML). Use tools only; no JS; workflow: `window_new` → `init_tool` → data prep (`web_search`) → `dom_replace_html`/render.
- [ ] Option (complex planning): Run Gui with Kimi K2 (moonshot-v2-1t) for 1T-parameter reasoning when layouts/interactions are very complex.
- [ ] Coding model: Kimi K2 for code generation/refactors. Route explicit code-gen requests to K2; keep UI orchestration with Gui unless “Gui-K2” mode is requested.
- [ ] Kimi K2 integration: Moonshot API (OpenAI-compatible). Model: `moonshot-v2-1t` (aka Kimi K2), context ~128K, temperature 0.5–0.7.
- [ ] Streaming: standard OpenAI-compatible streaming for K2; JSON function/tool-calling where available. If tool-calling fails, fall back to strict line‑DSL (post‑MVP).
- [ ] System prompt (K2): leverage 1T param reasoning for complex UI planning; tools only; no JS; see `docs/prompts/gui.md`.
- [ ] Retry/repair loop for invalid tool args (validator feedback → auto‑fix prompt).

## 5) Orchestrator Backend
- [ ] Node/TypeScript service (Next API route or standalone server).
- [ ] WebSocket broker to relay commands to the correct client session.
- [ ] Tool executor registry; idempotency and ordering guarantees per window.
- [ ] Sanitizer service (server-side) for double-protection.
- [ ] Search proxy (`web_search`) with caching and rate limits.
- [ ] Logging of tool calls and results (truncate large payloads).

## 6) Persistence (Local‑first)
- [ ] Prisma + SQLite at `data/app.db`.
- [ ] Migrations for:
  - [ ] `User(id, email, password_hash, created_at)`
  - [ ] `Project(id, user_id, name, created_at, last_opened_at)`
  - [ ] `Workspace(id, project_id, name, status, created_at)`
  - [ ] `Window(id, workspace_id, title, size, x, y, z, created_at, updated_at)`
  - [ ] `WindowContent(id, window_id, html, version, created_at)` (latest per window)
  - [ ] `Artifact(id, window_id, type:"web|md|diagram", meta_json)`
  - [ ] `ChatMessage(id, workspace_id, role, channel, content, created_at)`
  - [ ] `ToolCall(id, workspace_id, tool, args_json, result_json, created_at)`
- [ ] Load last session on login; autosave window content/layout.

## 7) Auth & Sessions
- [ ] Auth.js (Credentials) for local dev.
- [ ] Session cookies + CSRF protection.
- [ ] Basic rate limiting and lockout after repeated failures.

## 8) Integrations (MVP)
- [ ] Chart.js driver: lazy-load, per-window registry; `chart_render` idempotent.
- [ ] Mermaid driver: `mermaid.initialize`, render by `id` safely.
- [ ] Leaflet maps (no API key) for `map_show`.
- [ ] Tailwind utilities allowed; no external CSS injection.

## 9) Safety & Governance
- [ ] Strict HTML allowlist; strip `style`, `script`, `on*`, `iframe`, remote URLs.
- [ ] Cap HTML payload size; chunk if needed.
- [ ] Selector validation: must resolve within window scope, else return error.
- [ ] Disable arbitrary network in browser; all fetch via backend proxy.
- [ ] Redact secrets; log sampling only.

## 10) Testing & QA
- [ ] Unit: command validator, DSL parser (if used), sanitizer.
- [ ] Integration: mock model → command sequence → window DOM assertions.
- [ ] E2E happy path: “Create dashboard → init chart → render → click updates → persist/reload.”
- [ ] Regression script: replay stored traces; confirm deterministic DOM.
- [ ] K2 stress tests: multi-window (≥5 windows), cross-window interactions, ensure state tracking across updates.
- [ ] Failure recovery: inject renderer failures (e.g., `chart_render`) and assert K2 proposes fallbacks (e.g., table view) or retries safely.

## 11) Developer Experience
- [ ] Scripts: `dev`, `build`, `lint`, `prisma:migrate`, `prisma:studio`.
- [ ] `.env.example` with local config; README quick start.
- [ ] Sample seed: creates a user, project, and demo window.
- [ ] `KIMI_API_KEY` in `.env` (retrieve from platform.moonshot.cn).
- [ ] Show K2 token usage per request in dev mode.
- [ ] Optional A/B: compare K2 vs smaller models for cost/latency.

## 12) Milestones & Acceptance
Milestone 1 — Shell & Transport (2 days)
- [ ] Desktop/windows UI, sanitizer, WS link, event delegation.

Milestone 2 — Tools & Renderers (2 days)
- [ ] `window_new`, `dom_replace_html`, `init_tool`, `chart_render`, `mermaid_render`, `map_show`.

Milestone 3 — Providers & Adapter (1–2 days)
- [ ] Wire Qwen 3 (Gui) and Kimi K2; streaming; constraints; validator/repair.

Milestone 4 — Model Integration (1.5 days)
- [ ] Kimi K2 API client with streaming (OpenAI-compatible).
- [ ] System prompt (leverage 1T params for complex planning).
- [ ] Tool call parsing (standard function-call format).
- [ ] Token usage tracking.

Acceptance (Milestone 4)
- [ ] Complex dashboard with 5+ windows.
- [ ] K2 orchestrates 10+ tool calls correctly.
- [ ] Self-corrects when tools fail.
- [ ] Total cost < $0.02 per complex interaction (approx.).

Milestone 5 — Persistence & Auth (1 day)
- [ ] Prisma schema/migrations; login; restore desktop.

Milestone 6 — QA & Polish (1 day)
- [ ] E2E demo script; logs; docs.

Acceptance Criteria
- [ ] Given: user prompts “Create a sales dashboard with a bar chart and a map.”
- [ ] Then: agent issues tool calls only; a window opens (`lg`) with title; chart renders via Chart.js; map renders via Leaflet.
- [ ] And: clicking a filter button triggers `ui_event` → agent updates chart.
- [ ] And: refresh/relogin restores the same desktop and artifacts.

## 13) Post‑MVP (Soon After)
- [ ] Publish read‑only artifact view; “Remix” clones to new workspace.
- [ ] (Optional) Sub‑agent routing per window (`spawn_subagent`).
- [ ] WebContainers or containerized runner for code artifacts.
- [ ] Deployment path: Postgres, S3 storage, container sandbox, OAuth.
- [ ] Usage dashboard, quotas, audit trail.

## 14) References
- [ ] Kimi K2 API docs: https://platform.moonshot.cn/docs
- [ ] Model: `moonshot-v2-1t` (aka Kimi K2), context ~128K.
- [ ] Temperature: 0.5–0.7 recommended.
- [ ] Optional fallback: Qwen2.5-72B or DeepSeek-V3 for cost/latency.
- [ ] Model formatting: update `docs/Model Formatting Req.md` with Qwen 3 tool-calling and Kimi K2 usage.
- [ ] Ollama/local notes: see `docs/ollama cloud vs. turbo.md` as applicable.
